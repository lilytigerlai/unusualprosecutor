<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>非常檢控觀 Nonogram</title>
    <style>
        :root {
            --cell-size: 25px; /* 格子大小 */
            --border-color: #333;
            --filled-color: #2c3e50;
            --x-color: #e74c3c;
            --highlight-bg: #f0f0f0;
        }

        body {
            font-family: 'Helvetica', 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fcfcfc;
            margin: 0;
            padding: 20px;
        }

        /* 新增 Logo 樣式 */
        .game-logo {
            max-width: 150px; /* 控制 Logo 大小 */
            height: auto;
            border-radius: 12px; /* 圓角 */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* 陰影 */
            margin-bottom: 15px;
        }

        h1 {
            margin-bottom: 10px;
            color: #333;
            margin-top: 0; /* 移除上方預設邊距 */
        }

        .controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* 讓按鈕在小螢幕自動換行 */
            justify-content: center;
        }

        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 4px;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #eee;
        }

        button.active {
            background-color: #333;
            color: white;
        }
        
        /* 特別為顯示答案按鈕設計樣式 */
        .solve-btn {
            border-color: #27ae60;
            color: #27ae60;
            font-weight: bold;
        }
        .solve-btn:hover {
            background-color: #27ae60;
            color: white;
        }

        #game-container {
            display: inline-block;
            user-select: none;
            -webkit-user-select: none;
        }

        table {
            border-collapse: collapse;
            border: 3px solid #000;
        }

        td {
            padding: 0;
            margin: 0;
            border: 1px solid #999;
        }

        /* 提示區塊樣式 */
        .clue-col {
            vertical-align: bottom;
            text-align: center;
            padding-bottom: 5px;
            min-height: 100px;
            background-color: #fff;
            line-height: 1.2;
            font-size: 14px;
        }

        .clue-row {
            text-align: right;
            padding-right: 8px;
            white-space: nowrap;
            min-width: 100px;
            background-color: #fff;
            font-size: 14px;
        }

        .clue-number {
            display: block; /* 直列數字垂直排列 */
        }
        
        .clue-row span {
            display: inline-block;
            margin-left: 4px;
        }

        /* 遊戲格子樣式 */
        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #fff;
            cursor: pointer;
            text-align: center;
            line-height: var(--cell-size);
            font-size: 18px;
        }

        .cell.filled {
            background-color: var(--filled-color);
        }

        .cell.crossed {
            color: var(--x-color);
        }
        
        .cell.crossed::after {
            content: '×';
        }

        /* 粗線分隔 (每5格) */
        .thick-right { border-right: 3px solid #000 !important; }
        .thick-bottom { border-bottom: 3px solid #000 !important; }

        /* 錯誤提示 */
        .error-clue { color: red; font-weight: bold; }
        
        /* 手機版優化 */
        @media (max-width: 600px) {
            :root { --cell-size: 20px; }
            .clue-row { font-size: 12px; min-width: 70px; }
            .clue-col { font-size: 12px; }
        }
    </style>
</head>
<body>

    <img src="Gemini_Generated_Image_smg1ucsmg1ucsmg1.jpg" alt="非常檢控觀 Logo" class="game-logo">

    <h1>非常檢控觀</h1>
    <p style="color:#666; font-size: 0.9em;">電腦：左鍵填色 / 右鍵打叉<br>手機：使用下方按鈕切換模式</p>

    <div class="controls">
        <button id="modeBtn" onclick="toggleMode()">目前模式：填色 (筆)</button>
        <button onclick="checkGame()">檢查答案</button>
        <button onclick="resetGame()">重置</button>
        <button onclick="autoSolve()" class="solve-btn">一鍵顯示答案</button>
    </div>

    <div id="game-container">
    </div>

    <script>
        // 數據錄入：根據圖片中的數字
        const colClues = [
            [7,1,4,1], [1,1,1,1,1,1], [7,1,1,1,5], [3,1,1], [7,1],
            [1,1,6], [7,1,1,1], [1,1,1], [7,6], [1,1,1],
            [4,1,4,1,1], [1,1,1,5], [7,1,1,1,1],[1,1,3,1,1], [4], 
            [6,3], [4,1,1,1,1,1],[4,1,1,1,1,1],[4,1,4,5], []
        ];

        const rowClues = [
            [1,1,3,3,3,1,1], [1,1,1,1,1,1,1,1,1,1], [1,1,1,1,1,1,1,1,1,1], [3,3,3,3,3], [1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [], [4,4,4,4], [1,1,1,1,1],
            [4,1,1,4,4], [1,1,1,1,1,1], [1,1,1,1,1,1], [4,4,4,4], [],
            [1,1,4], [2,2,1,1], [1,2,1,4], [1,1,1], [5,5,1]
        ];

        const gridSize = 20;
        let gridState = Array(gridSize).fill().map(() => Array(gridSize).fill(0)); // 0: empty, 1: filled, 2: crossed
        let isMouseDown = false;
        let currentDrawMode = 1; // 1: fill, 2: cross
        let mobileMode = 1; // 1: fill, 2: cross

        function initGame() {
            const table = document.createElement('table');
            
            // 建立表頭 (Column Clues)
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            // 左上角空白格
            headerRow.appendChild(document.createElement('td'));

            colClues.forEach((clue, index) => {
                const td = document.createElement('td');
                td.className = 'clue-col';
                if ((index + 1) % 5 === 0 && index !== gridSize - 1) td.classList.add('thick-right');
                
                clue.forEach(num => {
                    const div = document.createElement('div');
                    div.className = 'clue-number';
                    div.textContent = num;
                    td.appendChild(div);
                });
                td.id = `col-clue-${index}`;
                headerRow.appendChild(td);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // 建立表格內容 (Row Clues + Grid)
            const tbody = document.createElement('tbody');
            
            for (let r = 0; r < gridSize; r++) {
                const tr = document.createElement('tr');
                
                // 左側 Row Clues
                const clueTd = document.createElement('td');
                clueTd.className = 'clue-row';
                if ((r + 1) % 5 === 0 && r !== gridSize - 1) clueTd.classList.add('thick-bottom');
                
                rowClues[r].forEach(num => {
                    const span = document.createElement('span');
                    span.textContent = num;
                    clueTd.appendChild(span);
                });
                clueTd.id = `row-clue-${r}`;
                tr.appendChild(clueTd);

                // 遊戲格子
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('td');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    if ((c + 1) % 5 === 0 && c !== gridSize - 1) cell.classList.add('thick-right');
                    if ((r + 1) % 5 === 0 && r !== gridSize - 1) cell.classList.add('thick-bottom');

                    // 滑鼠事件
                    cell.addEventListener('mousedown', (e) => handleMouseDown(e, r, c));
                    cell.addEventListener('mouseover', (e) => handleMouseOver(e, r, c));
                    cell.addEventListener('contextmenu', (e) => e.preventDefault()); 

                    tr.appendChild(cell);
                }
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);
            
            const container = document.getElementById('game-container');
            container.innerHTML = '';
            container.appendChild(table);

            document.addEventListener('mouseup', () => { isMouseDown = false; });
            refreshGridVisuals(); // 確保初始載入正確
        }

        function handleMouseDown(e, r, c) {
            e.preventDefault();
            isMouseDown = true;
            
            let action = mobileMode; 
            if (e.button === 2) action = 2; // Right click

            const currentVal = gridState[r][c];
            
            if (currentVal === action) {
                currentDrawMode = 0; // Erase
            } else {
                currentDrawMode = action;
            }

            updateCell(r, c, currentDrawMode);
        }

        function handleMouseOver(e, r, c) {
            if (isMouseDown) {
                updateCell(r, c, currentDrawMode);
            }
        }

        function updateCell(r, c, state) {
            if (gridState[r][c] === state) return;
            gridState[r][c] = state;
            
            const cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);
            cell.classList.remove('filled', 'crossed');
            
            if (state === 1) cell.classList.add('filled');
            if (state === 2) cell.classList.add('crossed');
        }
        
        // 刷新所有格子的視覺狀態 (用於解題後)
        function refreshGridVisuals() {
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    const cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);
                    if(!cell) continue;
                    cell.classList.remove('filled', 'crossed');
                    if(gridState[r][c] === 1) cell.classList.add('filled');
                    if(gridState[r][c] === 2) cell.classList.add('crossed');
                }
            }
        }

        function toggleMode() {
            const btn = document.getElementById('modeBtn');
            if (mobileMode === 1) {
                mobileMode = 2;
                btn.textContent = "目前模式：打叉 (X)";
                btn.style.backgroundColor = "#e74c3c";
                btn.style.color = "white";
            } else {
                mobileMode = 1;
                btn.textContent = "目前模式：填色 (筆)";
                btn.style.backgroundColor = "#fff";
                btn.style.color = "black";
            }
        }

        function getLineClues(line) {
            const clues = [];
            let count = 0;
            for (let val of line) {
                if (val === 1) {
                    count++;
                } else if (count > 0) {
                    clues.push(count);
                    count = 0;
                }
            }
            if (count > 0) clues.push(count);
            return clues;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function checkGame() {
            let allCorrect = true;

            // Check Rows
            for (let r = 0; r < gridSize; r++) {
                const currentClues = getLineClues(gridState[r]);
                const clueEl = document.getElementById(`row-clue-${r}`);
                if (!arraysEqual(currentClues, rowClues[r])) {
                    clueEl.classList.add('error-clue');
                    allCorrect = false;
                } else {
                    clueEl.classList.remove('error-clue');
                }
            }

            // Check Cols
            for (let c = 0; c < gridSize; c++) {
                const col = [];
                for (let r = 0; r < gridSize; r++) col.push(gridState[r][c]);
                const currentClues = getLineClues(col);
                const clueEl = document.getElementById(`col-clue-${c}`);
                if (!arraysEqual(currentClues, colClues[c])) {
                    clueEl.classList.add('error-clue');
                    allCorrect = false;
                } else {
                    clueEl.classList.remove('error-clue');
                }
            }

            if (allCorrect) {
                alert("恭喜！你成功解開了謎題！(非常檢控觀)");
            } else {
                alert("還有錯誤喔，請檢查紅色標記的提示數字。");
            }
        }

        function resetGame() {
            if(confirm("確定要重置遊戲嗎？")) {
                gridState = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
                document.querySelectorAll('.cell').forEach(c => c.classList.remove('filled', 'crossed'));
                document.querySelectorAll('.error-clue').forEach(c => c.classList.remove('error-clue'));
            }
        }

        // ==========================================
        // 自動解題邏輯 (Auto Solver)
        // ==========================================
        
        function autoSolve() {
            if(!confirm("確定要顯示正確答案嗎？這將會覆蓋您目前的進度。")) return;

            // 初始化解題狀態 (0: 未知, 1: 填色, 2: 空白/打叉)
            // 注意：這裡暫存用 -1 代表空白，方便計算，最後再轉回 2
            let solverGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));

            let changed = true;
            let loops = 0;

            // 簡單的邏輯迭代求解 (Line Intersection Logic)
            while(changed && loops < 100) {
                changed = false;
                loops++;

                // 處理每一行
                for(let r=0; r<gridSize; r++) {
                    const rowLine = solverGrid[r];
                    const newLine = solveLine(rowLine, rowClues[r], gridSize);
                    if(newLine) {
                        for(let c=0; c<gridSize; c++) {
                            if(solverGrid[r][c] === 0 && newLine[c] !== 0) {
                                solverGrid[r][c] = newLine[c];
                                changed = true;
                            }
                        }
                    }
                }

                // 處理每一列
                for(let c=0; c<gridSize; c++) {
                    const colLine = [];
                    for(let r=0; r<gridSize; r++) colLine.push(solverGrid[r][c]);
                    
                    const newLine = solveLine(colLine, colClues[c], gridSize);
                    if(newLine) {
                        for(let r=0; r<gridSize; r++) {
                            if(solverGrid[r][c] === 0 && newLine[r] !== 0) {
                                solverGrid[r][c] = newLine[r];
                                changed = true;
                            }
                        }
                    }
                }
            }

            // 將結果填回遊戲狀態
            // Solver: 1=Filled, -1=Empty(Cross). Game: 1=Filled, 2=Crossed
            for(let r=0; r<gridSize; r++) {
                for(let c=0; c<gridSize; c++) {
                    if(solverGrid[r][c] === 1) gridState[r][c] = 1;
                    if(solverGrid[r][c] === -1) gridState[r][c] = 2; 
                    // 0 保持不變或視為打叉? 通常未解開的部分保持原樣，但此題邏輯應該能全解
                }
            }
            
            refreshGridVisuals();
            // 移除錯誤提示
            document.querySelectorAll('.error-clue').forEach(c => c.classList.remove('error-clue'));
        }

        // 計算單行的可能性交集
        function solveLine(currentLine, clues, length) {
            // 生成該行所有可能的排列組合
            const possibilities = [];
            
            function generate(index, clueIdx, currentArr) {
                // Base case: 所有提示都已放置
                if (clueIdx === clues.length) {
                    // 檢查剩餘空間是否足以填補空白 (不能有 1)
                    // 但因為我們是依序填，只要剩餘長度足夠補 0 即可
                    const remaining = length - index;
                    const result = currentArr.concat(Array(remaining).fill(-1)); // 剩餘補空白
                    possibilities.push(result);
                    return;
                }

                const clue = clues[clueIdx];
                // 剩餘需要的最小空間: 本提示長度 + (如果還有後續提示，至少1格空白) + 後續提示總長 + 後續提示所需間隔
                let remainingClues = clues.slice(clueIdx + 1);
                let minSpaceNeeded = clue + (remainingClues.length > 0 ? 1 : 0) + 
                                     remainingClues.reduce((a, b) => a + b, 0) + 
                                     (remainingClues.length > 0 ? remainingClues.length - 1 : 0);
                
                // 可放置的最遠起始點
                let maxStart = length - minSpaceNeeded - index; // 修正邏輯

                // 實際計算：當前位置 index 最遠能去哪？
                // 剩餘長度 available = length - index
                // 需求 need = minSpaceNeeded (at current clue start)
                // slack = available - need
                // start pos can range from index to index + slack
                
                // 修正剩餘空間計算
                let sumRest = remainingClues.reduce((a,b)=>a+b,0);
                let gapsRest = remainingClues.length; 
                let minTotal = clue + sumRest + gapsRest; // Current block + rests + all gaps (incl after current)
                
                // 這是簡化版遞迴，嘗試從 index 開始的每一個可能位置放置 clue
                // 限制：位置必須能容納 clue，且如果是第一個以後的 clue，前面必須有空格
                
                // 為了效能與簡便，針對單行 20 格，我們可以用比較直觀的遞迴
                // 嘗試將當前 clue 放在 i 位置 (i >= index)
                
                // 優化：計算最晚可以放哪
                let spaceAfter = sumRest + gapsRest; // 後面需要的最小空間
                let maxPos = length - spaceAfter - clue;

                for(let i = index; i <= maxPos; i++) {
                    // 建立新的陣列片段
                    // 前面補空白 (從 index 到 i-1)
                    let prefix = [];
                    for(let k=index; k<i; k++) prefix.push(-1);
                    
                    // 放 clue
                    let block = [];
                    for(let k=0; k<clue; k++) block.push(1);
                    
                    // 如果不是最後一個提示，必須至少跟一個空白
                    let suffix = [];
                    if(clueIdx < clues.length - 1) {
                        suffix.push(-1);
                    }
                    
                    // 遞迴
                    let nextIndex = i + clue + (clueIdx < clues.length - 1 ? 1 : 0);
                    generate(nextIndex, clueIdx + 1, currentArr.concat(prefix, block, suffix));
                }
            }

            generate(0, 0, []);

            // 過濾掉與 currentLine 已知狀態 (使用者手填的錯誤不算，這裡指 Solver 已確認的) 衝突的排列
            // 但因為我們是從零開始解，這裡 currentLine 傳入的可能是 Solver 上一輪的結果
            // 必須過濾掉與 currentLine 中「已確定(非0)」不符的項目
            const validPossibilities = possibilities.filter(p => {
                for(let i=0; i<length; i++) {
                    if(currentLine[i] !== 0 && currentLine[i] !== p[i]) return false;
                }
                return true;
            });

            if(validPossibilities.length === 0) return null; // 無解或矛盾

            // 計算交集 (Intersection)
            // 如果所有有效排列在某個位置都是 1，則該位置為 1
            // 如果所有有效排列在某個位置都是 -1，則該位置為 -1
            // 否則為 0
            const resultLine = Array(length).fill(0);
            for(let i=0; i<length; i++) {
                let allOne = true;
                let allEmpty = true;
                for(let p of validPossibilities) {
                    if(p[i] !== 1) allOne = false;
                    if(p[i] !== -1) allEmpty = false;
                }
                if(allOne) resultLine[i] = 1;
                else if(allEmpty) resultLine[i] = -1;
            }
            return resultLine;
        }

        // 初始化
        initGame();
    </script>
</body>
</html>